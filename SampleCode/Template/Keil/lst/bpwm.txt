; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\bpwm.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\bpwm.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\bpwm.crf ..\..\..\Library\StdDriver\src\bpwm.c]
                          THUMB

                          AREA ||i.BPWM_ClearADCTriggerFlag||, CODE, READONLY, ALIGN=1

                  BPWM_ClearADCTriggerFlag PROC
;;;312     */
;;;313    void BPWM_ClearADCTriggerFlag(BPWM_T *bpwm, uint32_t u32ChannelNum, uint32_t u32Condition)
000000  f44f127c          MOV      r2,#0x3f0000
;;;314    {
;;;315        (bpwm)->STATUS = (BPWM_STATUS_EADCTRGn_Msk << u32ChannelNum);
000004  408a              LSLS     r2,r2,r1
000006  f8c02120          STR      r2,[r0,#0x120]
;;;316    }
00000a  4770              BX       lr
;;;317    
                          ENDP


                          AREA ||i.BPWM_ClearCaptureIntFlag||, CODE, READONLY, ALIGN=1

                  BPWM_ClearCaptureIntFlag PROC
;;;440     */
;;;441    void BPWM_ClearCaptureIntFlag(BPWM_T *bpwm, uint32_t u32ChannelNum, uint32_t u32Edge)
000000  408a              LSLS     r2,r2,r1
;;;442    {
;;;443        (bpwm)->CAPIF = (u32Edge << u32ChannelNum);
000002  f8c02254          STR      r2,[r0,#0x254]
;;;444    }
000006  4770              BX       lr
;;;445    
                          ENDP


                          AREA ||i.BPWM_ClearDutyIntFlag||, CODE, READONLY, ALIGN=2

                  BPWM_ClearDutyIntFlag PROC
;;;503     */
;;;504    void BPWM_ClearDutyIntFlag(BPWM_T *bpwm, uint32_t u32ChannelNum)
000000  4a02              LDR      r2,|L3.12|
;;;505    {
;;;506        (bpwm)->INTSTS = (BPWM_INTSTS_CMPUIFn_Msk | BPWM_INTSTS_CMPDIFn_Msk) << u32ChannelNum;
000002  408a              LSLS     r2,r2,r1
000004  f8c020e8          STR      r2,[r0,#0xe8]
;;;507    }
000008  4770              BX       lr
;;;508    
                          ENDP

00000a  0000              DCW      0x0000
                  |L3.12|
                          DCD      0x3f3f0000

                          AREA ||i.BPWM_ClearPeriodIntFlag||, CODE, READONLY, ALIGN=1

                  BPWM_ClearPeriodIntFlag PROC
;;;565     */
;;;566    void BPWM_ClearPeriodIntFlag(BPWM_T *bpwm, uint32_t u32ChannelNum)
000000  f44f7180          MOV      r1,#0x100
;;;567    {
;;;568        (bpwm)->INTSTS = BPWM_INTSTS_PIF0_Msk;
000004  f8c010e8          STR      r1,[r0,#0xe8]
;;;569    }
000008  4770              BX       lr
;;;570    
                          ENDP


                          AREA ||i.BPWM_ClearWrapAroundFlag||, CODE, READONLY, ALIGN=1

                  BPWM_ClearWrapAroundFlag PROC
;;;731     */
;;;732    void BPWM_ClearWrapAroundFlag(BPWM_T *bpwm, uint32_t u32ChannelNum)
000000  2101              MOVS     r1,#1
;;;733    {
;;;734        (bpwm)->STATUS = BPWM_STATUS_CNTMAX0_Msk;
000002  f8c01120          STR      r1,[r0,#0x120]
;;;735    }
000006  4770              BX       lr
;;;736    
                          ENDP


                          AREA ||i.BPWM_ClearZeroIntFlag||, CODE, READONLY, ALIGN=1

                  BPWM_ClearZeroIntFlag PROC
;;;627     */
;;;628    void BPWM_ClearZeroIntFlag(BPWM_T *bpwm, uint32_t u32ChannelNum)
000000  2101              MOVS     r1,#1
;;;629    {
;;;630        (bpwm)->INTSTS = BPWM_INTSTS_ZIF0_Msk;
000002  f8c010e8          STR      r1,[r0,#0xe8]
;;;631    }
000006  4770              BX       lr
;;;632    
                          ENDP


                          AREA ||i.BPWM_ConfigCaptureChannel||, CODE, READONLY, ALIGN=2

                  BPWM_ConfigCaptureChannel PROC
;;;33      */
;;;34     uint32_t BPWM_ConfigCaptureChannel(BPWM_T *bpwm, uint32_t u32ChannelNum, uint32_t u32UnitTimeNsec, uint32_t u32CaptureEdge)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;35     {
000004  4605              MOV      r5,r0
;;;36         uint32_t u32Src;
;;;37         uint32_t u32PWMClockSrc;
;;;38         uint32_t u32NearestUnitTimeNsec;
;;;39         uint16_t u16Prescale = 1U, u16CNR = 0xFFFFU;
000006  2401              MOVS     r4,#1
;;;40     
;;;41         if(bpwm == BPWM0)
;;;42         {
;;;43             u32Src = CLK->CLKSEL2 & CLK_CLKSEL2_BPWM0SEL_Msk;
000008  07a0              LSLS     r0,r4,#30
00000a  f8df8078          LDR      r8,|L7.132|
;;;44         }
;;;45         else     /* (bpwm == BPWM1) */
;;;46         {
;;;47             u32Src = CLK->CLKSEL2 & CLK_CLKSEL2_BPWM1SEL_Msk;
00000e  f8d00218          LDR      r0,[r0,#0x218]
000012  4617              MOV      r7,r2                 ;35
000014  f64f76ff          MOV      r6,#0xffff            ;39
000018  4545              CMP      r5,r8                 ;41
00001a  d102              BNE      |L7.34|
00001c  f4007080          AND      r0,r0,#0x100          ;43
000020  e001              B        |L7.38|
                  |L7.34|
000022  f4007000          AND      r0,r0,#0x200
                  |L7.38|
;;;48         }
;;;49     
;;;50         if(u32Src == 0U)
000026  b130              CBZ      r0,|L7.54|
;;;51         {
;;;52             /* clock source is from PLL clock */
;;;53             u32PWMClockSrc = CLK_GetPLLClockFreq();
;;;54         }
;;;55         else
;;;56         {
;;;57             /* clock source is from PCLK */
;;;58             SystemCoreClockUpdate();
000028  f7fffffe          BL       SystemCoreClockUpdate
;;;59             if(bpwm == BPWM0)
00002c  4545              CMP      r5,r8
00002e  d105              BNE      |L7.60|
;;;60             {
;;;61                 u32PWMClockSrc = CLK_GetPCLK0Freq();
000030  f7fffffe          BL       CLK_GetPCLK0Freq
000034  e004              B        |L7.64|
                  |L7.54|
000036  f7fffffe          BL       CLK_GetPLLClockFreq
00003a  e001              B        |L7.64|
                  |L7.60|
;;;62             }
;;;63             else    /* (bpwm == BPWM1) */
;;;64             {
;;;65                 u32PWMClockSrc = CLK_GetPCLK1Freq();
00003c  f7fffffe          BL       CLK_GetPCLK1Freq
                  |L7.64|
;;;66             }
;;;67         }
;;;68     
;;;69         u32PWMClockSrc /= 1000UL;
000040  f44f717a          MOV      r1,#0x3e8
000044  fbb0f2f1          UDIV     r2,r0,r1
;;;70         for(u16Prescale = 1U; u16Prescale <= 0x1000U; u16Prescale++)
;;;71         {
;;;72             uint32_t u32Exit = 0U;
;;;73             u32NearestUnitTimeNsec = (1000000UL * u16Prescale) / u32PWMClockSrc;
;;;74             if(u32NearestUnitTimeNsec < u32UnitTimeNsec)
;;;75             {
;;;76                 if (u16Prescale == 0x1000U)   /* limit to the maximum unit time(nano second) */
000048  f44f5880          MOV      r8,#0x1000
                  |L7.76|
00004c  480e              LDR      r0,|L7.136|
00004e  4360              MULS     r0,r4,r0              ;73
000050  fbb0f0f2          UDIV     r0,r0,r2              ;73
000054  42b8              CMP      r0,r7                 ;74
000056  d20c              BCS      |L7.114|
;;;77                 {
;;;78                     u32Exit = 1U;
;;;79                 }
;;;80                 else
;;;81                 {
;;;82                     u32Exit = 0U;
;;;83                 }
;;;84                 if (!(1000000UL * (u16Prescale + 1UL) > (u32NearestUnitTimeNsec * u32PWMClockSrc)))
000058  1c61              ADDS     r1,r4,#1
00005a  f6435c09          MOV      r12,#0x3d09
00005e  fb00f302          MUL      r3,r0,r2
000062  fb01fc0c          MUL      r12,r1,r12
000066  ebb31f8c          CMP      r3,r12,LSL #6
00006a  d202              BCS      |L7.114|
00006c  b28c              UXTH     r4,r1                 ;70
00006e  4544              CMP      r4,r8                 ;70
;;;85                 {
;;;86                     u32Exit = 1U;
;;;87                 }
;;;88                 else
;;;89                 {
;;;90                     u32Exit = 0U;
000070  d9ec              BLS      |L7.76|
                  |L7.114|
000072  1e64              SUBS     r4,r4,#1
;;;91                 }
;;;92             }
;;;93             else
;;;94             {
;;;95                 u32Exit = 1U;
;;;96             }
;;;97             if (u32Exit == 1U)
;;;98             {
;;;99                 break;
;;;100            }
;;;101            else {}
;;;102        }
;;;103    
;;;104        /* convert to real register value */
;;;105        /* all channels share a prescaler */
;;;106        u16Prescale -= 1U;
000074  b2a1              UXTH     r1,r4
;;;107        BPWM_SET_PRESCALER(bpwm, u32ChannelNum, u16Prescale);
000076  6169              STR      r1,[r5,#0x14]
;;;108    
;;;109        /* set BPWM to down count type(edge aligned) */
;;;110        (bpwm)->CTL1 = (1UL);
000078  2101              MOVS     r1,#1
00007a  6069              STR      r1,[r5,#4]
;;;111    
;;;112        BPWM_SET_CNR(bpwm, u32ChannelNum, u16CNR);
00007c  632e              STR      r6,[r5,#0x30]
;;;113    
;;;114        return (u32NearestUnitTimeNsec);
;;;115    }
00007e  e8bd81f0          POP      {r4-r8,pc}
;;;116    
                          ENDP

000082  0000              DCW      0x0000
                  |L7.132|
                          DCD      0x4005a000
                  |L7.136|
                          DCD      0x000f4240

                          AREA ||i.BPWM_ConfigOutputChannel||, CODE, READONLY, ALIGN=2

                  BPWM_ConfigOutputChannel PROC
;;;128     */
;;;129    uint32_t BPWM_ConfigOutputChannel(BPWM_T *bpwm, uint32_t u32ChannelNum, uint32_t u32Frequency, uint32_t u32DutyCycle)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;130    {
000004  4604              MOV      r4,r0
;;;131        uint32_t u32Src;
;;;132        uint32_t u32PWMClockSrc;
;;;133        uint32_t i;
;;;134        uint32_t u32Prescale = 1U, u32CNR = 0xFFFFU;
000006  2501              MOVS     r5,#1
;;;135    
;;;136        if(bpwm == BPWM0)
;;;137        {
;;;138            u32Src = CLK->CLKSEL2 & CLK_CLKSEL2_BPWM0SEL_Msk;
000008  07a8              LSLS     r0,r5,#30
00000a  f8dfa0d0          LDR      r10,|L8.220|
;;;139        }
;;;140        else     /* (bpwm == BPWM1) */
;;;141        {
;;;142            u32Src = CLK->CLKSEL2 & CLK_CLKSEL2_BPWM1SEL_Msk;
00000e  f8d00218          LDR      r0,[r0,#0x218]
000012  4698              MOV      r8,r3                 ;130
000014  4691              MOV      r9,r2                 ;130
000016  460f              MOV      r7,r1                 ;130
000018  f64f76ff          MOV      r6,#0xffff            ;134
00001c  4554              CMP      r4,r10                ;136
00001e  d102              BNE      |L8.38|
000020  f4007080          AND      r0,r0,#0x100          ;138
000024  e001              B        |L8.42|
                  |L8.38|
000026  f4007000          AND      r0,r0,#0x200
                  |L8.42|
;;;143        }
;;;144    
;;;145        if(u32Src == 0U)
00002a  b130              CBZ      r0,|L8.58|
;;;146        {
;;;147            /* clock source is from PLL clock */
;;;148            u32PWMClockSrc = CLK_GetPLLClockFreq();
;;;149        }
;;;150        else
;;;151        {
;;;152            /* clock source is from PCLK */
;;;153            SystemCoreClockUpdate();
00002c  f7fffffe          BL       SystemCoreClockUpdate
;;;154            if(bpwm == BPWM0)
000030  4554              CMP      r4,r10
000032  d105              BNE      |L8.64|
;;;155            {
;;;156                u32PWMClockSrc = CLK_GetPCLK0Freq();
000034  f7fffffe          BL       CLK_GetPCLK0Freq
000038  e004              B        |L8.68|
                  |L8.58|
00003a  f7fffffe          BL       CLK_GetPLLClockFreq
00003e  e001              B        |L8.68|
                  |L8.64|
;;;157            }
;;;158            else     /* (bpwm == BPWM1) */
;;;159            {
;;;160                u32PWMClockSrc = CLK_GetPCLK1Freq();
000040  f7fffffe          BL       CLK_GetPCLK1Freq
                  |L8.68|
;;;161            }
;;;162        }
;;;163    
;;;164        for(u32Prescale = 1U; u32Prescale < 0xFFFU; u32Prescale++)   /* prescale could be 0~0xFFF */
;;;165        {
;;;166            i = (u32PWMClockSrc / u32Frequency) / u32Prescale;
;;;167            /* If target value is larger than CNR, need to use a larger prescaler */
;;;168            if(i < (0x10000U))
000044  f44f3380          MOV      r3,#0x10000
000048  f64072ff          MOV      r2,#0xfff             ;164
                  |L8.76|
00004c  fbb0f1f9          UDIV     r1,r0,r9              ;166
000050  fbb1f1f5          UDIV     r1,r1,r5              ;166
000054  4299              CMP      r1,r3
000056  d201              BCS      |L8.92|
;;;169            {
;;;170                u32CNR = i;
000058  460e              MOV      r6,r1
;;;171                break;
00005a  e002              B        |L8.98|
                  |L8.92|
00005c  1c6d              ADDS     r5,r5,#1
00005e  4295              CMP      r5,r2                 ;164
000060  d3f4              BCC      |L8.76|
                  |L8.98|
;;;172            }
;;;173        }
;;;174        /* Store return value here 'cos we're gonna change u16Prescale & u16CNR to the real value to fill into register */
;;;175        i = u32PWMClockSrc / (u32Prescale * u32CNR);
000062  fb05f106          MUL      r1,r5,r6
000066  fbb0f9f1          UDIV     r9,r0,r1
00006a  1e6d              SUBS     r5,r5,#1
;;;176    
;;;177        /* convert to real register value */
;;;178        /* all channels share a prescaler */
;;;179        u32Prescale -= 1U;
;;;180        BPWM_SET_PRESCALER(bpwm, u32ChannelNum, u32Prescale);
00006c  6165              STR      r5,[r4,#0x14]
;;;181        /* set BPWM to down count type(edge aligned) */
;;;182        (bpwm)->CTL1 = (1UL);
00006e  2501              MOVS     r5,#1
000070  6065              STR      r5,[r4,#4]
000072  1e76              SUBS     r6,r6,#1
;;;183    
;;;184        u32CNR -= 1U;
;;;185        BPWM_SET_CNR(bpwm, u32ChannelNum, u32CNR);
000074  6326              STR      r6,[r4,#0x30]
;;;186        if(u32DutyCycle)
;;;187        {
;;;188            BPWM_SET_CMR(bpwm, u32ChannelNum, u32DutyCycle * (u32CNR + 1UL) / 100UL - 1UL);
;;;189            (bpwm)->WGCTL0 &= ~((BPWM_WGCTL0_PRDPCTLn_Msk | BPWM_WGCTL0_ZPCTLn_Msk) << (u32ChannelNum * 2U));
;;;190            (bpwm)->WGCTL0 |= (BPWM_OUTPUT_LOW << ((u32ChannelNum * (2U)) + (uint32_t)BPWM_WGCTL0_PRDPCTLn_Pos));
000076  2310              MOVS     r3,#0x10
;;;191            (bpwm)->WGCTL1 &= ~((BPWM_WGCTL1_CMPDCTLn_Msk | BPWM_WGCTL1_CMPUCTLn_Msk) << (u32ChannelNum * 2U));
;;;192            (bpwm)->WGCTL1 |= (BPWM_OUTPUT_HIGH << (u32ChannelNum * (2U) + (uint32_t)BPWM_WGCTL1_CMPDCTLn_Pos));
000078  2102              MOVS     r1,#2
00007a  eb030c47          ADD      r12,r3,r7,LSL #1      ;190
00007e  fa01f10c          LSL      r1,r1,r12
000082  f06f20f0          MVN      r0,#0xf000f000        ;189
000086  007b              LSLS     r3,r7,#1              ;189
000088  4098              LSLS     r0,r0,r3              ;189
00008a  eb040287          ADD      r2,r4,r7,LSL #2       ;188
00008e  f1b80f00          CMP      r8,#0                 ;186
000092  d00f              BEQ      |L8.180|
000094  1c76              ADDS     r6,r6,#1              ;186
000096  fb08f306          MUL      r3,r8,r6              ;188
00009a  2664              MOVS     r6,#0x64              ;188
00009c  fbb3f3f6          UDIV     r3,r3,r6              ;188
0000a0  1e5b              SUBS     r3,r3,#1              ;188
0000a2  6513              STR      r3,[r2,#0x50]         ;188
0000a4  f8542fb0          LDR      r2,[r4,#0xb0]!        ;189
0000a8  4382              BICS     r2,r2,r0              ;189
0000aa  6022              STR      r2,[r4,#0]            ;189
0000ac  6822              LDR      r2,[r4,#0]            ;190
0000ae  fa05f50c          LSL      r5,r5,r12             ;190
0000b2  e007              B        |L8.196|
                  |L8.180|
;;;193        }
;;;194        else
;;;195        {
;;;196            BPWM_SET_CMR(bpwm, u32ChannelNum, 0U);
0000b4  2600              MOVS     r6,#0
0000b6  6516              STR      r6,[r2,#0x50]
;;;197            (bpwm)->WGCTL0 &= ~((BPWM_WGCTL0_PRDPCTLn_Msk | BPWM_WGCTL0_ZPCTLn_Msk) << (u32ChannelNum * 2U));
0000b8  f8542fb0          LDR      r2,[r4,#0xb0]!
0000bc  4382              BICS     r2,r2,r0
0000be  6022              STR      r2,[r4,#0]
;;;198            (bpwm)->WGCTL0 |= (BPWM_OUTPUT_LOW << (u32ChannelNum * 2U + (uint32_t)BPWM_WGCTL0_ZPCTLn_Pos));
0000c0  6822              LDR      r2,[r4,#0]
0000c2  409d              LSLS     r5,r5,r3
                  |L8.196|
0000c4  432a              ORRS     r2,r2,r5
0000c6  6022              STR      r2,[r4,#0]
;;;199            (bpwm)->WGCTL1 &= ~((BPWM_WGCTL1_CMPDCTLn_Msk | BPWM_WGCTL1_CMPUCTLn_Msk) << (u32ChannelNum * 2U));
0000c8  6862              LDR      r2,[r4,#4]
0000ca  4382              BICS     r2,r2,r0
0000cc  6062              STR      r2,[r4,#4]
;;;200            (bpwm)->WGCTL1 |= (BPWM_OUTPUT_HIGH << (u32ChannelNum * 2U + (uint32_t)BPWM_WGCTL1_CMPDCTLn_Pos));
0000ce  6860              LDR      r0,[r4,#4]
0000d0  4308              ORRS     r0,r0,r1
0000d2  6060              STR      r0,[r4,#4]
;;;201        }
;;;202    
;;;203        return(i);
0000d4  4648              MOV      r0,r9
;;;204    }
0000d6  e8bd87f0          POP      {r4-r10,pc}
;;;205    
                          ENDP

0000da  0000              DCW      0x0000
                  |L8.220|
                          DCD      0x4005a000

                          AREA ||i.BPWM_DisableADCTrigger||, CODE, READONLY, ALIGN=1

                  BPWM_DisableADCTrigger PROC
;;;290     */
;;;291    void BPWM_DisableADCTrigger(BPWM_T *bpwm, uint32_t u32ChannelNum)
000000  00ca              LSLS     r2,r1,#3
;;;292    {
;;;293        if(u32ChannelNum < 4U)
;;;294        {
;;;295            (bpwm)->EADCTS0 &= ~(BPWM_EADCTS0_TRGEN0_Msk << (u32ChannelNum * 8U));
000002  2380              MOVS     r3,#0x80
000004  2904              CMP      r1,#4                 ;293
000006  d203              BCS      |L9.16|
000008  f8501ff8          LDR      r1,[r0,#0xf8]!
00000c  4093              LSLS     r3,r3,r2
00000e  e003              B        |L9.24|
                  |L9.16|
000010  3a20              SUBS     r2,r2,#0x20
;;;296        }
;;;297        else
;;;298        {
;;;299            (bpwm)->EADCTS1 &= ~(BPWM_EADCTS1_TRGEN4_Msk << ((u32ChannelNum - 4U) * 8U));
000012  f8501ffc          LDR      r1,[r0,#0xfc]!
000016  4093              LSLS     r3,r3,r2
                  |L9.24|
000018  4399              BICS     r1,r1,r3              ;295
00001a  6001              STR      r1,[r0,#0]            ;295
;;;300        }
;;;301    }
00001c  4770              BX       lr
;;;302    
                          ENDP


                          AREA ||i.BPWM_DisableCapture||, CODE, READONLY, ALIGN=1

                  BPWM_DisableCapture PROC
;;;358     */
;;;359    void BPWM_DisableCapture(BPWM_T *bpwm, uint32_t u32ChannelMask)
000000  f8d02200          LDR      r2,[r0,#0x200]
;;;360    {
;;;361        (bpwm)->CAPINEN &= ~u32ChannelMask;
000004  438a              BICS     r2,r2,r1
000006  f8c02200          STR      r2,[r0,#0x200]
;;;362        (bpwm)->CAPCTL &= ~u32ChannelMask;
00000a  f8d02204          LDR      r2,[r0,#0x204]
00000e  438a              BICS     r2,r2,r1
000010  f8c02204          STR      r2,[r0,#0x204]
;;;363    }
000014  4770              BX       lr
;;;364    
                          ENDP


                          AREA ||i.BPWM_DisableCaptureInt||, CODE, READONLY, ALIGN=1

                  BPWM_DisableCaptureInt PROC
;;;423     */
;;;424    void BPWM_DisableCaptureInt(BPWM_T *bpwm, uint32_t u32ChannelNum, uint32_t u32Edge)
000000  f8d03250          LDR      r3,[r0,#0x250]
;;;425    {
;;;426        (bpwm)->CAPIEN &= ~(u32Edge << u32ChannelNum);
000004  408a              LSLS     r2,r2,r1
000006  4393              BICS     r3,r3,r2
000008  f8c03250          STR      r3,[r0,#0x250]
;;;427    }
00000c  4770              BX       lr
;;;428    
                          ENDP


                          AREA ||i.BPWM_DisableDutyInt||, CODE, READONLY, ALIGN=2

                  BPWM_DisableDutyInt PROC
;;;488     */
;;;489    void BPWM_DisableDutyInt(BPWM_T *bpwm, uint32_t u32ChannelNum)
000000  f8502fe0          LDR      r2,[r0,#0xe0]!
;;;490    {
;;;491    
;;;492        (bpwm)->INTEN &= ~((uint32_t)(BPWM_DUTY_INT_DOWN_COUNT_MATCH_CMP | BPWM_DUTY_INT_UP_COUNT_MATCH_CMP) << u32ChannelNum);
000004  4b02              LDR      r3,|L12.16|
000006  408b              LSLS     r3,r3,r1
000008  439a              BICS     r2,r2,r3
00000a  6002              STR      r2,[r0,#0]
;;;493    }
00000c  4770              BX       lr
;;;494    
                          ENDP

00000e  0000              DCW      0x0000
                  |L12.16|
                          DCD      0x01010000

                          AREA ||i.BPWM_DisableLoadMode||, CODE, READONLY, ALIGN=1

                  BPWM_DisableLoadMode PROC
;;;678     */
;;;679    void BPWM_DisableLoadMode(BPWM_T *bpwm, uint32_t u32ChannelNum, uint32_t u32LoadMode)
000000  6803              LDR      r3,[r0,#0]
;;;680    {
;;;681        (bpwm)->CTL0 &= ~(u32LoadMode << u32ChannelNum);
000002  408a              LSLS     r2,r2,r1
000004  4393              BICS     r3,r3,r2
000006  6003              STR      r3,[r0,#0]
;;;682    }
000008  4770              BX       lr
;;;683    
                          ENDP


                          AREA ||i.BPWM_DisableOutput||, CODE, READONLY, ALIGN=1

                  BPWM_DisableOutput PROC
;;;389     */
;;;390    void BPWM_DisableOutput(BPWM_T *bpwm, uint32_t u32ChannelMask)
000000  f8502fd8          LDR      r2,[r0,#0xd8]!
;;;391    {
;;;392        (bpwm)->POEN &= ~u32ChannelMask;
000004  438a              BICS     r2,r2,r1
000006  6002              STR      r2,[r0,#0]
;;;393    }
000008  4770              BX       lr
;;;394    
                          ENDP


                          AREA ||i.BPWM_DisablePeriodInt||, CODE, READONLY, ALIGN=1

                  BPWM_DisablePeriodInt PROC
;;;550     */
;;;551    void BPWM_DisablePeriodInt(BPWM_T *bpwm, uint32_t u32ChannelNum)
000000  f8501fe0          LDR      r1,[r0,#0xe0]!
;;;552    {
;;;553        (bpwm)->INTEN &= ~BPWM_INTEN_PIEN0_Msk;
000004  f4217180          BIC      r1,r1,#0x100
000008  6001              STR      r1,[r0,#0]
;;;554    }
00000a  4770              BX       lr
;;;555    
                          ENDP


                          AREA ||i.BPWM_DisableZeroInt||, CODE, READONLY, ALIGN=1

                  BPWM_DisableZeroInt PROC
;;;612     */
;;;613    void BPWM_DisableZeroInt(BPWM_T *bpwm, uint32_t u32ChannelNum)
000000  f8501fe0          LDR      r1,[r0,#0xe0]!
;;;614    {
;;;615        (bpwm)->INTEN &= ~BPWM_INTEN_ZIEN0_Msk;
000004  f0210101          BIC      r1,r1,#1
000008  6001              STR      r1,[r0,#0]
;;;616    }
00000a  4770              BX       lr
;;;617    
                          ENDP


                          AREA ||i.BPWM_EnableADCTrigger||, CODE, READONLY, ALIGN=1

                  BPWM_EnableADCTrigger PROC
;;;267     */
;;;268    void BPWM_EnableADCTrigger(BPWM_T *bpwm, uint32_t u32ChannelNum, uint32_t u32Condition)
000000  b510              PUSH     {r4,lr}
;;;269    {
;;;270        if(u32ChannelNum < 4U)
;;;271        {
;;;272            (bpwm)->EADCTS0 &= ~((BPWM_EADCTS0_TRGSEL0_Msk) << (u32ChannelNum * 8U));
;;;273            (bpwm)->EADCTS0 |= ((BPWM_EADCTS0_TRGEN0_Msk | u32Condition) << (u32ChannelNum * 8U));
000002  f0420380          ORR      r3,r2,#0x80
000006  240f              MOVS     r4,#0xf               ;272
000008  00ca              LSLS     r2,r1,#3              ;272
00000a  2904              CMP      r1,#4                 ;270
00000c  d203              BCS      |L17.22|
00000e  f8501ff8          LDR      r1,[r0,#0xf8]!        ;272
000012  4094              LSLS     r4,r4,r2              ;272
000014  e003              B        |L17.30|
                  |L17.22|
000016  3a20              SUBS     r2,r2,#0x20
;;;274        }
;;;275        else
;;;276        {
;;;277            (bpwm)->EADCTS1 &= ~((BPWM_EADCTS1_TRGSEL4_Msk) << ((u32ChannelNum - 4U) * 8U));
000018  f8501ffc          LDR      r1,[r0,#0xfc]!
00001c  4094              LSLS     r4,r4,r2
                  |L17.30|
00001e  43a1              BICS     r1,r1,r4              ;272
000020  6001              STR      r1,[r0,#0]            ;272
000022  6801              LDR      r1,[r0,#0]            ;273
000024  4093              LSLS     r3,r3,r2              ;273
000026  430b              ORRS     r3,r3,r1              ;273
000028  6003              STR      r3,[r0,#0]            ;273
;;;278            (bpwm)->EADCTS1 |= ((BPWM_EADCTS1_TRGEN4_Msk | u32Condition) << ((u32ChannelNum - 4U) * 8U));
;;;279        }
;;;280    }
00002a  bd10              POP      {r4,pc}
;;;281    
                          ENDP


                          AREA ||i.BPWM_EnableCapture||, CODE, READONLY, ALIGN=1

                  BPWM_EnableCapture PROC
;;;342     */
;;;343    void BPWM_EnableCapture(BPWM_T *bpwm, uint32_t u32ChannelMask)
000000  f8d02200          LDR      r2,[r0,#0x200]
;;;344    {
;;;345        (bpwm)->CAPINEN |= u32ChannelMask;
000004  430a              ORRS     r2,r2,r1
000006  f8c02200          STR      r2,[r0,#0x200]
;;;346        (bpwm)->CAPCTL |= u32ChannelMask;
00000a  f8d02204          LDR      r2,[r0,#0x204]
00000e  430a              ORRS     r2,r2,r1
000010  f8c02204          STR      r2,[r0,#0x204]
;;;347    }
000014  4770              BX       lr
;;;348    
                          ENDP


                          AREA ||i.BPWM_EnableCaptureInt||, CODE, READONLY, ALIGN=1

                  BPWM_EnableCaptureInt PROC
;;;406     */
;;;407    void BPWM_EnableCaptureInt(BPWM_T *bpwm, uint32_t u32ChannelNum, uint32_t u32Edge)
000000  f8d03250          LDR      r3,[r0,#0x250]
;;;408    {
;;;409        (bpwm)->CAPIEN |= (u32Edge << u32ChannelNum);
000004  408a              LSLS     r2,r2,r1
000006  4313              ORRS     r3,r3,r2
000008  f8c03250          STR      r3,[r0,#0x250]
;;;410    }
00000c  4770              BX       lr
;;;411    
                          ENDP


                          AREA ||i.BPWM_EnableDutyInt||, CODE, READONLY, ALIGN=1

                  BPWM_EnableDutyInt PROC
;;;474     */
;;;475    void BPWM_EnableDutyInt(BPWM_T *bpwm, uint32_t u32ChannelNum, uint32_t u32IntDutyType)
000000  f8503fe0          LDR      r3,[r0,#0xe0]!
;;;476    {
;;;477        (bpwm)->INTEN |= (u32IntDutyType << u32ChannelNum);
000004  408a              LSLS     r2,r2,r1
000006  4313              ORRS     r3,r3,r2
000008  6003              STR      r3,[r0,#0]
;;;478    }
00000a  4770              BX       lr
;;;479    
                          ENDP


                          AREA ||i.BPWM_EnableLoadMode||, CODE, READONLY, ALIGN=1

                  BPWM_EnableLoadMode PROC
;;;661     */
;;;662    void BPWM_EnableLoadMode(BPWM_T *bpwm, uint32_t u32ChannelNum, uint32_t u32LoadMode)
000000  6803              LDR      r3,[r0,#0]
;;;663    {
;;;664        (bpwm)->CTL0 |= (u32LoadMode << u32ChannelNum);
000002  408a              LSLS     r2,r2,r1
000004  4313              ORRS     r3,r3,r2
000006  6003              STR      r3,[r0,#0]
;;;665    }
000008  4770              BX       lr
;;;666    
                          ENDP


                          AREA ||i.BPWM_EnableOutput||, CODE, READONLY, ALIGN=1

                  BPWM_EnableOutput PROC
;;;374     */
;;;375    void BPWM_EnableOutput(BPWM_T *bpwm, uint32_t u32ChannelMask)
000000  f8502fd8          LDR      r2,[r0,#0xd8]!
;;;376    {
;;;377        (bpwm)->POEN |= u32ChannelMask;
000004  430a              ORRS     r2,r2,r1
000006  6002              STR      r2,[r0,#0]
;;;378    }
000008  4770              BX       lr
;;;379    
                          ENDP


                          AREA ||i.BPWM_EnablePeriodInt||, CODE, READONLY, ALIGN=1

                  BPWM_EnablePeriodInt PROC
;;;535     */
;;;536    void BPWM_EnablePeriodInt(BPWM_T *bpwm, uint32_t u32ChannelNum,  uint32_t u32IntPeriodType)
000000  f8501fe0          LDR      r1,[r0,#0xe0]!
;;;537    {
;;;538        (bpwm)->INTEN |= BPWM_INTEN_PIEN0_Msk;
000004  f4417180          ORR      r1,r1,#0x100
000008  6001              STR      r1,[r0,#0]
;;;539    }
00000a  4770              BX       lr
;;;540    
                          ENDP


                          AREA ||i.BPWM_EnableZeroInt||, CODE, READONLY, ALIGN=1

                  BPWM_EnableZeroInt PROC
;;;597     */
;;;598    void BPWM_EnableZeroInt(BPWM_T *bpwm, uint32_t u32ChannelNum)
000000  f8501fe0          LDR      r1,[r0,#0xe0]!
;;;599    {
;;;600        (bpwm)->INTEN |= BPWM_INTEN_ZIEN0_Msk;
000004  f0410101          ORR      r1,r1,#1
000008  6001              STR      r1,[r0,#0]
;;;601    }
00000a  4770              BX       lr
;;;602    
                          ENDP


                          AREA ||i.BPWM_ForceStop||, CODE, READONLY, ALIGN=1

                  BPWM_ForceStop PROC
;;;245     */
;;;246    void BPWM_ForceStop(BPWM_T *bpwm, uint32_t u32ChannelMask)
000000  6a01              LDR      r1,[r0,#0x20]
;;;247    {
;;;248        (bpwm)->CNTEN &= ~BPWM_CNTEN_CNTEN0_Msk;
000002  f0210101          BIC      r1,r1,#1
000006  6201              STR      r1,[r0,#0x20]
;;;249    }
000008  4770              BX       lr
;;;250    
                          ENDP


                          AREA ||i.BPWM_GetADCTriggerFlag||, CODE, READONLY, ALIGN=1

                  BPWM_GetADCTriggerFlag PROC
;;;327     */
;;;328    uint32_t BPWM_GetADCTriggerFlag(BPWM_T *bpwm, uint32_t u32ChannelNum)
000000  f8d00120          LDR      r0,[r0,#0x120]
;;;329    {
;;;330        return (((bpwm)->STATUS & (BPWM_STATUS_EADCTRGn_Msk << u32ChannelNum)) ? 1UL : 0UL);
000004  f44f127c          MOV      r2,#0x3f0000
000008  408a              LSLS     r2,r2,r1
00000a  4010              ANDS     r0,r0,r2
00000c  d000              BEQ      |L26.16|
00000e  2001              MOVS     r0,#1
                  |L26.16|
;;;331    }
000010  4770              BX       lr
;;;332    
                          ENDP


                          AREA ||i.BPWM_GetCaptureIntFlag||, CODE, READONLY, ALIGN=1

                  BPWM_GetCaptureIntFlag PROC
;;;457     */
;;;458    uint32_t BPWM_GetCaptureIntFlag(BPWM_T *bpwm, uint32_t u32ChannelNum)
000000  f8d02254          LDR      r2,[r0,#0x254]
;;;459    {
;;;460        return (((((bpwm)->CAPIF & (BPWM_CAPIF_CAPFIFn_Msk << u32ChannelNum)) ? 1UL : 0UL) << 1) | \
000004  233f              MOVS     r3,#0x3f
000006  408b              LSLS     r3,r3,r1
000008  401a              ANDS     r2,r2,r3
00000a  d000              BEQ      |L27.14|
;;;461                (((bpwm)->CAPIF & (BPWM_CAPIF_CAPRIFn_Msk << u32ChannelNum)) ? 1UL : 0UL));
00000c  2201              MOVS     r2,#1
                  |L27.14|
00000e  f8d00254          LDR      r0,[r0,#0x254]
000012  f44f537c          MOV      r3,#0x3f00
000016  408b              LSLS     r3,r3,r1
000018  4018              ANDS     r0,r0,r3
00001a  d000              BEQ      |L27.30|
00001c  2001              MOVS     r0,#1                 ;460
                  |L27.30|
00001e  ea420040          ORR      r0,r2,r0,LSL #1       ;460
;;;462    }
000022  4770              BX       lr
;;;463    /**
                          ENDP


                          AREA ||i.BPWM_GetDutyIntFlag||, CODE, READONLY, ALIGN=2

                  BPWM_GetDutyIntFlag PROC
;;;519     */
;;;520    uint32_t BPWM_GetDutyIntFlag(BPWM_T *bpwm, uint32_t u32ChannelNum)
000000  f8d000e8          LDR      r0,[r0,#0xe8]
;;;521    {
;;;522        return ((((bpwm)->INTSTS & ((BPWM_INTSTS_CMPDIFn_Msk | BPWM_INTSTS_CMPUIFn_Msk) << u32ChannelNum))) ? 1UL : 0UL);
000004  4a02              LDR      r2,|L28.16|
000006  408a              LSLS     r2,r2,r1
000008  4010              ANDS     r0,r0,r2
00000a  d000              BEQ      |L28.14|
00000c  2001              MOVS     r0,#1
                  |L28.14|
;;;523    }
00000e  4770              BX       lr
;;;524    
                          ENDP

                  |L28.16|
                          DCD      0x3f3f0000

                          AREA ||i.BPWM_GetPeriodIntFlag||, CODE, READONLY, ALIGN=1

                  BPWM_GetPeriodIntFlag PROC
;;;582     */
;;;583    uint32_t BPWM_GetPeriodIntFlag(BPWM_T *bpwm, uint32_t u32ChannelNum)
000000  f8d000e8          LDR      r0,[r0,#0xe8]
;;;584    {
;;;585        return (((bpwm)->INTSTS & BPWM_INTSTS_PIF0_Msk) ? 1UL : 0UL);
000004  f3c02000          UBFX     r0,r0,#8,#1
;;;586    }
000008  4770              BX       lr
;;;587    
                          ENDP


                          AREA ||i.BPWM_GetWrapAroundFlag||, CODE, READONLY, ALIGN=1

                  BPWM_GetWrapAroundFlag PROC
;;;716     */
;;;717    uint32_t BPWM_GetWrapAroundFlag(BPWM_T *bpwm, uint32_t u32ChannelNum)
000000  f8d00120          LDR      r0,[r0,#0x120]
;;;718    {
;;;719        return (((bpwm)->STATUS & BPWM_STATUS_CNTMAX0_Msk) ? 1UL : 0UL);
000004  f3c00000          UBFX     r0,r0,#0,#1
;;;720    }
000008  4770              BX       lr
;;;721    
                          ENDP


                          AREA ||i.BPWM_GetZeroIntFlag||, CODE, READONLY, ALIGN=1

                  BPWM_GetZeroIntFlag PROC
;;;644     */
;;;645    uint32_t BPWM_GetZeroIntFlag(BPWM_T *bpwm, uint32_t u32ChannelNum)
000000  f8d000e8          LDR      r0,[r0,#0xe8]
;;;646    {
;;;647        return (((bpwm)->INTSTS & BPWM_INTSTS_ZIF0_Msk) ? 1UL : 0UL);
000004  f3c00000          UBFX     r0,r0,#0,#1
;;;648    }
000008  4770              BX       lr
;;;649    
                          ENDP


                          AREA ||i.BPWM_SetClockSource||, CODE, READONLY, ALIGN=1

                  BPWM_SetClockSource PROC
;;;699     */
;;;700    void BPWM_SetClockSource(BPWM_T *bpwm, uint32_t u32ChannelNum, uint32_t u32ClkSrcSel)
000000  6102              STR      r2,[r0,#0x10]
;;;701    {
;;;702        (bpwm)->CLKSRC = (u32ClkSrcSel);
;;;703    }
000002  4770              BX       lr
;;;704    
                          ENDP


                          AREA ||i.BPWM_Start||, CODE, READONLY, ALIGN=1

                  BPWM_Start PROC
;;;215     */
;;;216    void BPWM_Start(BPWM_T *bpwm, uint32_t u32ChannelMask)
000000  2101              MOVS     r1,#1
;;;217    {
;;;218        (bpwm)->CNTEN = BPWM_CNTEN_CNTEN0_Msk;
000002  6201              STR      r1,[r0,#0x20]
;;;219    }
000004  4770              BX       lr
;;;220    
                          ENDP


                          AREA ||i.BPWM_Stop||, CODE, READONLY, ALIGN=1

                  BPWM_Stop PROC
;;;230     */
;;;231    void BPWM_Stop(BPWM_T *bpwm, uint32_t u32ChannelMask)
000000  2100              MOVS     r1,#0
;;;232    {
;;;233        (bpwm)->PERIOD = 0U;
000002  6301              STR      r1,[r0,#0x30]
;;;234    }
000004  4770              BX       lr
;;;235    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\bpwm.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_bpwm_c_a5cc1395____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_bpwm_c_a5cc1395____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_bpwm_c_a5cc1395____REVSH|
#line 402
|__asm___6_bpwm_c_a5cc1395____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_bpwm_c_a5cc1395____RRX|
#line 587
|__asm___6_bpwm_c_a5cc1395____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
