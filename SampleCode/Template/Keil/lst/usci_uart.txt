; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\usci_uart.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\usci_uart.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\usci_uart.crf ..\..\..\Library\StdDriver\src\usci_uart.c]
                          THUMB

                          AREA ||i.UUART_ClearIntFlag||, CODE, READONLY, ALIGN=1

                  UUART_ClearIntFlag PROC
;;;43     
;;;44     void UUART_ClearIntFlag(UUART_T* uuart, uint32_t u32Mask)
000000  078a              LSLS     r2,r1,#30
;;;45     {
000002  d502              BPL      |L1.10|
;;;46     
;;;47         if(u32Mask & UUART_ABR_INT_MASK)   /* Clear Auto-baud Rate Interrupt */
;;;48         {
;;;49             uuart->PROTSTS = UUART_PROTSTS_ABRDETIF_Msk;
000004  f44f7200          MOV      r2,#0x200
000008  6642              STR      r2,[r0,#0x64]
                  |L1.10|
;;;50         }
;;;51     
;;;52         if(u32Mask & UUART_RLS_INT_MASK)   /* Clear Receive Line Status Interrupt */
00000a  074a              LSLS     r2,r1,#29
00000c  d501              BPL      |L1.18|
;;;53         {
;;;54             uuart->PROTSTS = (UUART_PROTSTS_BREAK_Msk | UUART_PROTSTS_FRMERR_Msk | UUART_PROTSTS_PARITYERR_Msk);
00000e  22e0              MOVS     r2,#0xe0
000010  6642              STR      r2,[r0,#0x64]
                  |L1.18|
;;;55         }
;;;56     
;;;57         if(u32Mask & UUART_BUF_RXOV_INT_MASK)   /* Clear Receive Buffer Over-run Error Interrupt */
000012  070b              LSLS     r3,r1,#28
;;;58         {
;;;59             uuart->BUFSTS = UUART_BUFSTS_RXOVIF_Msk;
000014  f04f0208          MOV      r2,#8
000018  d500              BPL      |L1.28|
00001a  63c2              STR      r2,[r0,#0x3c]
                  |L1.28|
;;;60         }
;;;61     
;;;62         if(u32Mask & UUART_TXST_INT_MASK)   /* Clear Transmit Start Interrupt */
00001c  06cb              LSLS     r3,r1,#27
00001e  d501              BPL      |L1.36|
;;;63         {
;;;64             uuart->PROTSTS = UUART_PROTSTS_TXSTIF_Msk;
000020  2302              MOVS     r3,#2
000022  6643              STR      r3,[r0,#0x64]
                  |L1.36|
;;;65         }
;;;66     
;;;67         if(u32Mask & UUART_TXEND_INT_MASK)   /* Clear Transmit End Interrupt */
000024  068b              LSLS     r3,r1,#26
000026  d501              BPL      |L1.44|
;;;68         {
;;;69             uuart->PROTSTS = UUART_PROTSTS_TXENDIF_Msk;
000028  2304              MOVS     r3,#4
00002a  6643              STR      r3,[r0,#0x64]
                  |L1.44|
;;;70         }
;;;71     
;;;72         if(u32Mask & UUART_RXST_INT_MASK)   /* Clear Receive Start Interrupt */
00002c  064b              LSLS     r3,r1,#25
00002e  d500              BPL      |L1.50|
;;;73         {
;;;74             uuart->PROTSTS = UUART_PROTSTS_RXSTIF_Msk;
000030  6642              STR      r2,[r0,#0x64]
                  |L1.50|
;;;75         }
;;;76     
;;;77         if(u32Mask & UUART_RXEND_INT_MASK)   /* Clear Receive End Interrupt */
000032  0609              LSLS     r1,r1,#24
000034  d501              BPL      |L1.58|
;;;78         {
;;;79             uuart->PROTSTS = UUART_PROTSTS_RXENDIF_Msk;
000036  2110              MOVS     r1,#0x10
000038  6641              STR      r1,[r0,#0x64]
                  |L1.58|
;;;80         }
;;;81     
;;;82     }
00003a  4770              BX       lr
;;;83     
                          ENDP


                          AREA ||i.UUART_Close||, CODE, READONLY, ALIGN=1

                  UUART_Close PROC
;;;178     */
;;;179    void UUART_Close(UUART_T* uuart)
000000  2100              MOVS     r1,#0
;;;180    {
;;;181        uuart->CTL = 0ul;
000002  6001              STR      r1,[r0,#0]
;;;182    }
000004  4770              BX       lr
;;;183    
                          ENDP


                          AREA ||i.UUART_DisableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UUART_DisableFlowCtrl PROC
;;;684     */
;;;685    void UUART_DisableFlowCtrl(UUART_T* uuart)
000000  6dc1              LDR      r1,[r0,#0x5c]
;;;686    {
;;;687        /* Disable CTS and RTS auto flow control function */
;;;688        uuart->PROTCTL &= ~(UUART_PROTCTL_RTSAUTOEN_Msk|UUART_PROTCTL_CTSAUTOEN_Msk);
000002  f0210118          BIC      r1,r1,#0x18
000006  65c1              STR      r1,[r0,#0x5c]
;;;689    }
000008  4770              BX       lr
;;;690    
                          ENDP


                          AREA ||i.UUART_DisableInt||, CODE, READONLY, ALIGN=1

                  UUART_DisableInt PROC
;;;203     */
;;;204    void UUART_DisableInt(UUART_T* uuart, uint32_t u32Mask)
000000  078a              LSLS     r2,r1,#30
;;;205    {
000002  d503              BPL      |L4.12|
;;;206    
;;;207        /* Disable Auto-baud rate interrupt flag */
;;;208        if((u32Mask & UUART_ABR_INT_MASK) == UUART_ABR_INT_MASK)
;;;209        {
;;;210            uuart->PROTIEN &= ~UUART_PROTIEN_ABRIEN_Msk;
000004  6e02              LDR      r2,[r0,#0x60]
000006  f0220202          BIC      r2,r2,#2
00000a  6602              STR      r2,[r0,#0x60]
                  |L4.12|
;;;211        }
;;;212    
;;;213        /* Disable receive line status interrupt flag */
;;;214        if((u32Mask & UUART_RLS_INT_MASK) == UUART_RLS_INT_MASK)
00000c  074a              LSLS     r2,r1,#29
00000e  d503              BPL      |L4.24|
;;;215        {
;;;216            uuart->PROTIEN &= ~UUART_PROTIEN_RLSIEN_Msk;
000010  6e02              LDR      r2,[r0,#0x60]
000012  f0220204          BIC      r2,r2,#4
000016  6602              STR      r2,[r0,#0x60]
                  |L4.24|
;;;217        }
;;;218    
;;;219        /* Disable RX overrun interrupt flag */
;;;220        if((u32Mask & UUART_BUF_RXOV_INT_MASK) == UUART_BUF_RXOV_INT_MASK)
000018  070a              LSLS     r2,r1,#28
00001a  d503              BPL      |L4.36|
;;;221        {
;;;222            uuart->BUFCTL &= ~UUART_BUFCTL_RXOVIEN_Msk;
00001c  6b82              LDR      r2,[r0,#0x38]
00001e  f4224280          BIC      r2,r2,#0x4000
000022  6382              STR      r2,[r0,#0x38]
                  |L4.36|
;;;223        }
;;;224    
;;;225        /* Disable TX start interrupt flag */
;;;226        if((u32Mask & UUART_TXST_INT_MASK) == UUART_TXST_INT_MASK)
000024  06ca              LSLS     r2,r1,#27
000026  d503              BPL      |L4.48|
;;;227        {
;;;228            uuart->INTEN &= ~UUART_INTEN_TXSTIEN_Msk;
000028  6842              LDR      r2,[r0,#4]
00002a  f0220202          BIC      r2,r2,#2
00002e  6042              STR      r2,[r0,#4]
                  |L4.48|
;;;229        }
;;;230    
;;;231        /* Disable TX end interrupt flag */
;;;232        if((u32Mask & UUART_TXEND_INT_MASK) == UUART_TXEND_INT_MASK)
000030  068a              LSLS     r2,r1,#26
000032  d503              BPL      |L4.60|
;;;233        {
;;;234            uuart->INTEN &= ~UUART_INTEN_TXENDIEN_Msk;
000034  6842              LDR      r2,[r0,#4]
000036  f0220204          BIC      r2,r2,#4
00003a  6042              STR      r2,[r0,#4]
                  |L4.60|
;;;235        }
;;;236    
;;;237        /* Disable RX start interrupt flag */
;;;238        if((u32Mask & UUART_RXST_INT_MASK) == UUART_RXST_INT_MASK)
00003c  064a              LSLS     r2,r1,#25
00003e  d503              BPL      |L4.72|
;;;239        {
;;;240            uuart->INTEN &= ~UUART_INTEN_RXSTIEN_Msk;
000040  6842              LDR      r2,[r0,#4]
000042  f0220208          BIC      r2,r2,#8
000046  6042              STR      r2,[r0,#4]
                  |L4.72|
;;;241        }
;;;242    
;;;243        /* Disable RX end interrupt flag */
;;;244        if((u32Mask & UUART_RXEND_INT_MASK) == UUART_RXEND_INT_MASK)
000048  0609              LSLS     r1,r1,#24
00004a  d503              BPL      |L4.84|
;;;245        {
;;;246            uuart->INTEN &= ~UUART_INTEN_RXENDIEN_Msk;
00004c  6841              LDR      r1,[r0,#4]
00004e  f0210110          BIC      r1,r1,#0x10
000052  6041              STR      r1,[r0,#4]
                  |L4.84|
;;;247        }
;;;248    }
000054  4770              BX       lr
;;;249    
                          ENDP


                          AREA ||i.UUART_DisableWakeup||, CODE, READONLY, ALIGN=1

                  UUART_DisableWakeup PROC
;;;648     */
;;;649    void UUART_DisableWakeup(UUART_T* uuart)
000000  6dc1              LDR      r1,[r0,#0x5c]
;;;650    {
;;;651        uuart->PROTCTL &= ~(UUART_PROTCTL_DATWKEN_Msk|UUART_PROTCTL_CTSWKEN_Msk);
000002  f42161c0          BIC      r1,r1,#0x600
000006  65c1              STR      r1,[r0,#0x5c]
;;;652        uuart->WKCTL &= ~UUART_WKCTL_WKEN_Msk;
000008  6d41              LDR      r1,[r0,#0x54]
00000a  f0210101          BIC      r1,r1,#1
00000e  6541              STR      r1,[r0,#0x54]
;;;653    }
000010  4770              BX       lr
;;;654    
                          ENDP


                          AREA ||i.UUART_EnableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UUART_EnableFlowCtrl PROC
;;;663     */
;;;664    void UUART_EnableFlowCtrl(UUART_T* uuart)
000000  6ac1              LDR      r1,[r0,#0x2c]
;;;665    {
;;;666        /* Set RTS signal is low level active */
;;;667        uuart->LINECTL &= ~UUART_LINECTL_CTLOINV_Msk;
000002  f0210180          BIC      r1,r1,#0x80
000006  62c1              STR      r1,[r0,#0x2c]
;;;668    
;;;669        /* Set CTS signal is low level active */
;;;670        uuart->CTLIN0 &= ~UUART_CTLIN0_ININV_Msk;
000008  6a01              LDR      r1,[r0,#0x20]
00000a  f0210104          BIC      r1,r1,#4
00000e  6201              STR      r1,[r0,#0x20]
;;;671    
;;;672        /* Enable CTS and RTS auto flow control function */
;;;673        uuart->PROTCTL |= UUART_PROTCTL_RTSAUTOEN_Msk|UUART_PROTCTL_CTSAUTOEN_Msk;
000010  6dc1              LDR      r1,[r0,#0x5c]
000012  f0410118          ORR      r1,r1,#0x18
000016  65c1              STR      r1,[r0,#0x5c]
;;;674    }
000018  4770              BX       lr
;;;675    
                          ENDP


                          AREA ||i.UUART_EnableInt||, CODE, READONLY, ALIGN=1

                  UUART_EnableInt PROC
;;;269     */
;;;270    void UUART_EnableInt(UUART_T*  uuart, uint32_t u32Mask)
000000  078a              LSLS     r2,r1,#30
;;;271    {
000002  d503              BPL      |L7.12|
;;;272        /* Enable Auto-baud rate interrupt flag */
;;;273        if((u32Mask & UUART_ABR_INT_MASK) == UUART_ABR_INT_MASK)
;;;274        {
;;;275            uuart->PROTIEN |= UUART_PROTIEN_ABRIEN_Msk;
000004  6e02              LDR      r2,[r0,#0x60]
000006  f0420202          ORR      r2,r2,#2
00000a  6602              STR      r2,[r0,#0x60]
                  |L7.12|
;;;276        }
;;;277    
;;;278        /* Enable receive line status interrupt flag */
;;;279        if((u32Mask & UUART_RLS_INT_MASK) == UUART_RLS_INT_MASK)
00000c  074a              LSLS     r2,r1,#29
00000e  d503              BPL      |L7.24|
;;;280        {
;;;281            uuart->PROTIEN |= UUART_PROTIEN_RLSIEN_Msk;
000010  6e02              LDR      r2,[r0,#0x60]
000012  f0420204          ORR      r2,r2,#4
000016  6602              STR      r2,[r0,#0x60]
                  |L7.24|
;;;282        }
;;;283    
;;;284        /* Enable RX overrun interrupt flag */
;;;285        if((u32Mask & UUART_BUF_RXOV_INT_MASK) == UUART_BUF_RXOV_INT_MASK)
000018  070a              LSLS     r2,r1,#28
00001a  d503              BPL      |L7.36|
;;;286        {
;;;287            uuart->BUFCTL |= UUART_BUFCTL_RXOVIEN_Msk;
00001c  6b82              LDR      r2,[r0,#0x38]
00001e  f4424280          ORR      r2,r2,#0x4000
000022  6382              STR      r2,[r0,#0x38]
                  |L7.36|
;;;288        }
;;;289    
;;;290        /* Enable TX start interrupt flag */
;;;291        if((u32Mask & UUART_TXST_INT_MASK) == UUART_TXST_INT_MASK)
000024  06ca              LSLS     r2,r1,#27
000026  d503              BPL      |L7.48|
;;;292        {
;;;293            uuart->INTEN |= UUART_INTEN_TXSTIEN_Msk;
000028  6842              LDR      r2,[r0,#4]
00002a  f0420202          ORR      r2,r2,#2
00002e  6042              STR      r2,[r0,#4]
                  |L7.48|
;;;294        }
;;;295    
;;;296        /* Enable TX end interrupt flag */
;;;297        if((u32Mask & UUART_TXEND_INT_MASK) == UUART_TXEND_INT_MASK)
000030  068a              LSLS     r2,r1,#26
000032  d503              BPL      |L7.60|
;;;298        {
;;;299            uuart->INTEN |= UUART_INTEN_TXENDIEN_Msk;
000034  6842              LDR      r2,[r0,#4]
000036  f0420204          ORR      r2,r2,#4
00003a  6042              STR      r2,[r0,#4]
                  |L7.60|
;;;300        }
;;;301    
;;;302        /* Enable RX start interrupt flag */
;;;303        if((u32Mask & UUART_RXST_INT_MASK) == UUART_RXST_INT_MASK)
00003c  064a              LSLS     r2,r1,#25
00003e  d503              BPL      |L7.72|
;;;304        {
;;;305            uuart->INTEN |= UUART_INTEN_RXSTIEN_Msk;
000040  6842              LDR      r2,[r0,#4]
000042  f0420208          ORR      r2,r2,#8
000046  6042              STR      r2,[r0,#4]
                  |L7.72|
;;;306        }
;;;307    
;;;308        /* Enable RX end interrupt flag */
;;;309        if((u32Mask & UUART_RXEND_INT_MASK) == UUART_RXEND_INT_MASK)
000048  0609              LSLS     r1,r1,#24
00004a  d503              BPL      |L7.84|
;;;310        {
;;;311            uuart->INTEN |= UUART_INTEN_RXENDIEN_Msk;
00004c  6841              LDR      r1,[r0,#4]
00004e  f0410110          ORR      r1,r1,#0x10
000052  6041              STR      r1,[r0,#4]
                  |L7.84|
;;;312        }
;;;313    }
000054  4770              BX       lr
;;;314    
                          ENDP


                          AREA ||i.UUART_EnableWakeup||, CODE, READONLY, ALIGN=1

                  UUART_EnableWakeup PROC
;;;632     */
;;;633    void UUART_EnableWakeup(UUART_T* uuart, uint32_t u32WakeupMode)
000000  6dc2              LDR      r2,[r0,#0x5c]
;;;634    {
;;;635        uuart->PROTCTL |= u32WakeupMode;
000002  430a              ORRS     r2,r2,r1
000004  65c2              STR      r2,[r0,#0x5c]
;;;636        uuart->WKCTL |= UUART_WKCTL_WKEN_Msk;
000006  6d41              LDR      r1,[r0,#0x54]
000008  f0410101          ORR      r1,r1,#1
00000c  6541              STR      r1,[r0,#0x54]
;;;637    }
00000e  4770              BX       lr
;;;638    
                          ENDP


                          AREA ||i.UUART_GetIntFlag||, CODE, READONLY, ALIGN=1

                  UUART_GetIntFlag PROC
;;;103    
;;;104    uint32_t UUART_GetIntFlag(UUART_T* uuart, uint32_t u32Mask)
000000  b510              PUSH     {r4,lr}
;;;105    {
000002  4602              MOV      r2,r0
;;;106        uint32_t u32IntFlag = 0ul;
000004  2000              MOVS     r0,#0
;;;107        uint32_t u32Tmp1, u32Tmp2;
;;;108    
;;;109        /* Check Auto-baud Rate Interrupt Flag */
;;;110        u32Tmp1 = (u32Mask & UUART_ABR_INT_MASK);
;;;111        u32Tmp2 = (uuart->PROTSTS & UUART_PROTSTS_ABRDETIF_Msk);
000006  6e54              LDR      r4,[r2,#0x64]
000008  f0110f02          TST      r1,#2                 ;110
00000c  f4047400          AND      r4,r4,#0x200
000010  d001              BEQ      |L9.22|
;;;112        if(u32Tmp1 && u32Tmp2)
000012  b104              CBZ      r4,|L9.22|
;;;113        {
;;;114            u32IntFlag |= UUART_ABR_INT_MASK;
000014  2002              MOVS     r0,#2
                  |L9.22|
;;;115        }
;;;116    
;;;117        /* Check Receive Line Status Interrupt Flag */
;;;118        u32Tmp1 = (u32Mask & UUART_RLS_INT_MASK);
;;;119        u32Tmp2 = (uuart->PROTSTS & (UUART_PROTSTS_BREAK_Msk | UUART_PROTSTS_FRMERR_Msk | UUART_PROTSTS_PARITYERR_Msk));
000016  6e54              LDR      r4,[r2,#0x64]
000018  f0110f04          TST      r1,#4                 ;118
00001c  f00404e0          AND      r4,r4,#0xe0
;;;120        if(u32Tmp1 && u32Tmp2)
000020  d002              BEQ      |L9.40|
000022  b10c              CBZ      r4,|L9.40|
;;;121        {
;;;122            u32IntFlag |= UUART_RLS_INT_MASK;
000024  f0400004          ORR      r0,r0,#4
                  |L9.40|
;;;123        }
;;;124    
;;;125        /* Check Receive Buffer Over-run Error Interrupt Flag */
;;;126        u32Tmp1 = (u32Mask & UUART_BUF_RXOV_INT_MASK);
;;;127        u32Tmp2 = (uuart->BUFSTS & UUART_BUFSTS_RXOVIF_Msk);
000028  6bd4              LDR      r4,[r2,#0x3c]
00002a  f0110f08          TST      r1,#8                 ;126
00002e  f0040408          AND      r4,r4,#8
;;;128        if(u32Tmp1 && u32Tmp2)
000032  d002              BEQ      |L9.58|
000034  b10c              CBZ      r4,|L9.58|
;;;129        {
;;;130            u32IntFlag |= UUART_BUF_RXOV_INT_MASK;
000036  f0400008          ORR      r0,r0,#8
                  |L9.58|
;;;131        }
;;;132    
;;;133        /* Check Transmit Start Interrupt Flag */
;;;134        u32Tmp1 = (u32Mask & UUART_TXST_INT_MASK);
;;;135        u32Tmp2 = (uuart->PROTSTS & UUART_PROTSTS_TXSTIF_Msk);
00003a  6e54              LDR      r4,[r2,#0x64]
00003c  f0110f10          TST      r1,#0x10              ;134
000040  f0040402          AND      r4,r4,#2
;;;136        if(u32Tmp1 && u32Tmp2)
000044  d002              BEQ      |L9.76|
000046  b10c              CBZ      r4,|L9.76|
;;;137        {
;;;138            u32IntFlag |= UUART_TXST_INT_MASK;
000048  f0400010          ORR      r0,r0,#0x10
                  |L9.76|
;;;139        }
;;;140    
;;;141        /* Check Transmit End Interrupt Flag */
;;;142        u32Tmp1 = (u32Mask & UUART_TXEND_INT_MASK);
;;;143        u32Tmp2 = (uuart->PROTSTS & UUART_PROTSTS_TXENDIF_Msk);
00004c  6e54              LDR      r4,[r2,#0x64]
00004e  f0110f20          TST      r1,#0x20              ;142
000052  f0040404          AND      r4,r4,#4
;;;144        if(u32Tmp1 && u32Tmp2)
000056  d002              BEQ      |L9.94|
000058  b10c              CBZ      r4,|L9.94|
;;;145        {
;;;146            u32IntFlag |= UUART_TXEND_INT_MASK;
00005a  f0400020          ORR      r0,r0,#0x20
                  |L9.94|
;;;147        }
;;;148    
;;;149        /* Check Receive Start Interrupt Flag */
;;;150        u32Tmp1 = (u32Mask & UUART_RXST_INT_MASK);
;;;151        u32Tmp2 = (uuart->PROTSTS & UUART_PROTSTS_RXSTIF_Msk);
00005e  6e54              LDR      r4,[r2,#0x64]
000060  f0110f40          TST      r1,#0x40              ;150
000064  f0040408          AND      r4,r4,#8
;;;152        if(u32Tmp1 && u32Tmp2)
000068  d002              BEQ      |L9.112|
00006a  b10c              CBZ      r4,|L9.112|
;;;153        {
;;;154            u32IntFlag |= UUART_RXST_INT_MASK;
00006c  f0400040          ORR      r0,r0,#0x40
                  |L9.112|
;;;155        }
;;;156    
;;;157        /* Check Receive End Interrupt Flag */
;;;158        u32Tmp1 = (u32Mask & UUART_RXEND_INT_MASK);
;;;159        u32Tmp2 = (uuart->PROTSTS & UUART_PROTSTS_RXENDIF_Msk);
000070  6e52              LDR      r2,[r2,#0x64]
000072  f0110f80          TST      r1,#0x80              ;158
000076  f0020210          AND      r2,r2,#0x10
;;;160        if(u32Tmp1 && u32Tmp2)
00007a  d003              BEQ      |L9.132|
00007c  2a00              CMP      r2,#0
00007e  d001              BEQ      |L9.132|
;;;161        {
;;;162            u32IntFlag |= UUART_RXEND_INT_MASK;
000080  f0400080          ORR      r0,r0,#0x80
                  |L9.132|
;;;163        }
;;;164    
;;;165        return u32IntFlag;
;;;166    
;;;167    }
000084  bd10              POP      {r4,pc}
;;;168    
                          ENDP


                          AREA ||i.UUART_Open||, CODE, READONLY, ALIGN=2

                  UUART_Open PROC
;;;325     */
;;;326    uint32_t UUART_Open(UUART_T* uuart, uint32_t u32baudrate)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;327    {
000004  4604              MOV      r4,r0
;;;328        uint32_t u32PCLKFreq, u32PDSCnt, u32DSCnt, u32ClkDiv;
;;;329        uint32_t u32Tmp, u32Tmp2, u32Min, u32MinClkDiv, u32MinDSCnt;
;;;330        uint32_t u32Div;
;;;331    
;;;332        /* Get PCLK frequency */
;;;333        if( uuart == UUART0)
000006  4837              LDR      r0,|L10.228|
000008  460d              MOV      r5,r1                 ;327
00000a  4284              CMP      r4,r0
00000c  d102              BNE      |L10.20|
;;;334        {
;;;335            u32PCLKFreq = CLK_GetPCLK0Freq();
00000e  f7fffffe          BL       CLK_GetPCLK0Freq
000012  e001              B        |L10.24|
                  |L10.20|
;;;336        }
;;;337        else
;;;338        {
;;;339            u32PCLKFreq = CLK_GetPCLK1Freq();
000014  f7fffffe          BL       CLK_GetPCLK1Freq
                  |L10.24|
000018  4684              MOV      r12,r0
;;;340        }
;;;341    
;;;342        u32Div = u32PCLKFreq / u32baudrate;
00001a  fbb0f0f5          UDIV     r0,r0,r5
;;;343        u32Tmp = (u32PCLKFreq / u32Div) - u32baudrate;
;;;344        u32Tmp2 = u32baudrate - (u32PCLKFreq / (u32Div+1ul));
00001e  1c42              ADDS     r2,r0,#1
000020  fbbcf1f0          UDIV     r1,r12,r0             ;343
000024  fbbcf2f2          UDIV     r2,r12,r2
000028  1b49              SUBS     r1,r1,r5              ;343
00002a  1aaa              SUBS     r2,r5,r2
;;;345    
;;;346        if(u32Tmp >= u32Tmp2) u32Div = u32Div + 1ul;
00002c  4291              CMP      r1,r2
00002e  d300              BCC      |L10.50|
000030  1c40              ADDS     r0,r0,#1
                  |L10.50|
;;;347    
;;;348        u32Tmp = 0x400ul * 0x10ul;
000032  f44f4280          MOV      r2,#0x4000
;;;349        for(u32PDSCnt = 1ul; u32PDSCnt <= 0x04ul; u32PDSCnt++)
000036  2301              MOVS     r3,#1
                  |L10.56|
;;;350        {
;;;351            if(u32Div <= (u32Tmp * u32PDSCnt)) break;
000038  fb02f103          MUL      r1,r2,r3
00003c  4281              CMP      r1,r0
00003e  d203              BCS      |L10.72|
000040  1c5b              ADDS     r3,r3,#1
000042  2b04              CMP      r3,#4                 ;349
000044  d9f8              BLS      |L10.56|
000046  e001              B        |L10.76|
                  |L10.72|
;;;352        }
;;;353    
;;;354        if(u32PDSCnt > 0x4ul) u32PDSCnt = 0x4ul;
000048  2b04              CMP      r3,#4
00004a  d900              BLS      |L10.78|
                  |L10.76|
00004c  2304              MOVS     r3,#4
                  |L10.78|
;;;355    
;;;356        u32Div = u32Div / u32PDSCnt;
00004e  fbb0f6f3          UDIV     r6,r0,r3
;;;357    
;;;358        /* Find best solution */
;;;359        u32Min = (uint32_t) - 1;
;;;360        u32MinDSCnt = 0ul;
000052  f04f0900          MOV      r9,#0
000056  f04f37ff          MOV      r7,#0xffffffff        ;359
;;;361        u32MinClkDiv = 0ul;
00005a  46c8              MOV      r8,r9
;;;362        u32Tmp = 0ul;
;;;363    
;;;364        for(u32DSCnt = 6ul; u32DSCnt <= 0x10ul; u32DSCnt++)   /* DSCNT could be 0x5~0xF */
00005c  2106              MOVS     r1,#6
;;;365        {
;;;366    
;;;367            u32ClkDiv = u32Div / u32DSCnt;
;;;368    
;;;369            if(u32ClkDiv > 0x400ul)
00005e  f44f6a80          MOV      r10,#0x400
                  |L10.98|
000062  fbb6f2f1          UDIV     r2,r6,r1              ;367
000066  4552              CMP      r2,r10
000068  d904              BLS      |L10.116|
;;;370            {
;;;371                u32ClkDiv = 0x400ul;
;;;372                u32Tmp = u32Div - (u32ClkDiv * u32DSCnt);
00006a  fb0a6511          MLS      r5,r10,r1,r6
00006e  4652              MOV      r2,r10                ;371
;;;373                u32Tmp2 = u32Tmp + 1ul;
000070  1c68              ADDS     r0,r5,#1
000072  e004              B        |L10.126|
                  |L10.116|
;;;374            }
;;;375            else
;;;376            {
;;;377                u32Tmp = u32Div - (u32ClkDiv * u32DSCnt);
;;;378                u32Tmp2 = ((u32ClkDiv+1ul) * u32DSCnt) - u32Div;
000074  1c50              ADDS     r0,r2,#1
000076  fb026511          MLS      r5,r2,r1,r6           ;377
00007a  4348              MULS     r0,r1,r0
00007c  1b80              SUBS     r0,r0,r6
                  |L10.126|
;;;379            }
;;;380    
;;;381            if(u32Tmp >= u32Tmp2)
00007e  4285              CMP      r5,r0
000080  d301              BCC      |L10.134|
000082  1c52              ADDS     r2,r2,#1
;;;382            {
;;;383                u32ClkDiv = u32ClkDiv + 1ul;
000084  e000              B        |L10.136|
                  |L10.134|
;;;384            }
;;;385            else u32Tmp2 = u32Tmp;
000086  4628              MOV      r0,r5
                  |L10.136|
;;;386    
;;;387            if(u32Tmp2 < u32Min)
000088  42b8              CMP      r0,r7
00008a  d203              BCS      |L10.148|
;;;388            {
;;;389                u32Min = u32Tmp2;
00008c  0007              MOVS     r7,r0
;;;390                u32MinDSCnt = u32DSCnt;
00008e  4689              MOV      r9,r1
;;;391                u32MinClkDiv = u32ClkDiv;
000090  4690              MOV      r8,r2
;;;392    
;;;393                /* Break when get good results */
;;;394                if(u32Min == 0ul)
000092  d002              BEQ      |L10.154|
                  |L10.148|
000094  1c49              ADDS     r1,r1,#1
000096  2910              CMP      r1,#0x10              ;364
000098  d9e3              BLS      |L10.98|
                  |L10.154|
;;;395                {
;;;396                    break;
;;;397                }
;;;398            }
;;;399        }
;;;400    
;;;401        /* Enable USCI_UART protocol */
;;;402        uuart->CTL &= ~UUART_CTL_FUNMODE_Msk;
00009a  6820              LDR      r0,[r4,#0]
00009c  f0200007          BIC      r0,r0,#7
0000a0  6020              STR      r0,[r4,#0]
;;;403        uuart->CTL = 2ul << UUART_CTL_FUNMODE_Pos;
0000a2  2002              MOVS     r0,#2
0000a4  6020              STR      r0,[r4,#0]
;;;404    
;;;405        /* Set USCI_UART line configuration */
;;;406        uuart->LINECTL = UUART_WORD_LEN_8 | UUART_LINECTL_LSB_Msk;
0000a6  f6400001          MOV      r0,#0x801
0000aa  62e0              STR      r0,[r4,#0x2c]
;;;407        uuart->DATIN0 = (2ul << UUART_DATIN0_EDGEDET_Pos);  /* Set falling edge detection */
0000ac  2010              MOVS     r0,#0x10
0000ae  6120              STR      r0,[r4,#0x10]
;;;408    
;;;409        /* Set USCI_UART baud rate */
;;;410        uuart->BRGEN = ((u32MinClkDiv-1ul) << UUART_BRGEN_CLKDIV_Pos) |
0000b0  490d              LDR      r1,|L10.232|
0000b2  f1a80001          SUB      r0,r8,#1
0000b6  eb012189          ADD      r1,r1,r9,LSL #10
0000ba  ea414000          ORR      r0,r1,r0,LSL #16
0000be  f06f01ff          MVN      r1,#0xff
0000c2  eb012103          ADD      r1,r1,r3,LSL #8
0000c6  4308              ORRS     r0,r0,r1
0000c8  60a0              STR      r0,[r4,#8]
;;;411                       ((u32MinDSCnt-1ul) << UUART_BRGEN_DSCNT_Pos) |
;;;412                       ((u32PDSCnt-1ul) << UUART_BRGEN_PDSCNT_Pos);
;;;413    
;;;414        uuart->PROTCTL |= UUART_PROTCTL_PROTEN_Msk;
0000ca  6de0              LDR      r0,[r4,#0x5c]
0000cc  f0404000          ORR      r0,r0,#0x80000000
0000d0  65e0              STR      r0,[r4,#0x5c]
;;;415    
;;;416        return (u32PCLKFreq/u32PDSCnt/u32MinDSCnt/u32MinClkDiv);
0000d2  fbbcf1f3          UDIV     r1,r12,r3
0000d6  fbb1f0f9          UDIV     r0,r1,r9
0000da  fbb0f0f8          UDIV     r0,r0,r8
;;;417    }
0000de  e8bd87f0          POP      {r4-r10,pc}
;;;418    
                          ENDP

0000e2  0000              DCW      0x0000
                  |L10.228|
                          DCD      0x400d0000
                  |L10.232|
                          DCD      0xfffffc00

                          AREA ||i.UUART_Read||, CODE, READONLY, ALIGN=1

                  UUART_Read PROC
;;;430     */
;;;431    uint32_t UUART_Read(UUART_T* uuart, uint8_t pu8RxBuf[], uint32_t u32ReadBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;432    {
000002  4604              MOV      r4,r0
;;;433        uint32_t  u32Count, u32delayno;
;;;434    
;;;435        for(u32Count = 0ul; u32Count < u32ReadBytes; u32Count++)
000004  2000              MOVS     r0,#0
;;;436        {
;;;437            u32delayno = 0ul;
;;;438    
;;;439            while(uuart->BUFSTS & UUART_BUFSTS_RXEMPTY_Msk)   /* Check RX empty => failed */
;;;440            {
;;;441                u32delayno++;
;;;442                if(u32delayno >= 0x40000000ul)
000006  f04f4580          MOV      r5,#0x40000000
00000a  e00c              B        |L11.38|
                  |L11.12|
00000c  2300              MOVS     r3,#0                 ;437
00000e  e002              B        |L11.22|
                  |L11.16|
000010  1c5b              ADDS     r3,r3,#1              ;439
000012  42ab              CMP      r3,r5
000014  d209              BCS      |L11.42|
                  |L11.22|
000016  6be6              LDR      r6,[r4,#0x3c]         ;439
000018  07f6              LSLS     r6,r6,#31             ;439
00001a  d1f9              BNE      |L11.16|
;;;443                {
;;;444                    break;
;;;445                }
;;;446            }
;;;447    
;;;448            if(u32delayno >= 0x40000000ul)
00001c  42ab              CMP      r3,r5
00001e  d204              BCS      |L11.42|
;;;449            {
;;;450                break;
;;;451            }
;;;452    
;;;453            pu8RxBuf[u32Count] = (uint8_t)uuart->RXDAT;    /* Get Data from USCI RX  */
000020  6b63              LDR      r3,[r4,#0x34]
000022  540b              STRB     r3,[r1,r0]
000024  1c40              ADDS     r0,r0,#1
                  |L11.38|
000026  4290              CMP      r0,r2                 ;435
000028  d3f0              BCC      |L11.12|
                  |L11.42|
;;;454        }
;;;455    
;;;456        return u32Count;
;;;457    
;;;458    }
00002a  bd70              POP      {r4-r6,pc}
;;;459    
                          ENDP


                          AREA ||i.UUART_SetLine_Config||, CODE, READONLY, ALIGN=2

                  UUART_SetLine_Config PROC
;;;483     */
;;;484    uint32_t UUART_SetLine_Config(UUART_T* uuart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t u32stop_bits)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;485    {
000004  4604              MOV      r4,r0
;;;486        uint32_t u32PCLKFreq, u32PDSCnt, u32DSCnt, u32ClkDiv;
;;;487        uint32_t u32Tmp, u32Tmp2, u32Min, u32MinClkDiv, u32MinDSCnt;
;;;488        uint32_t u32Div;
;;;489    
;;;490        /* Get PCLK frequency */
;;;491        if(uuart == UUART0)
000006  4842              LDR      r0,|L12.272|
000008  4693              MOV      r11,r2                ;485
00000a  460d              MOV      r5,r1                 ;485
00000c  4284              CMP      r4,r0
00000e  d102              BNE      |L12.22|
;;;492        {
;;;493            u32PCLKFreq = CLK_GetPCLK0Freq();
000010  f7fffffe          BL       CLK_GetPCLK0Freq
000014  e001              B        |L12.26|
                  |L12.22|
;;;494        }
;;;495        else     /* UUART1 */
;;;496        {
;;;497            u32PCLKFreq = CLK_GetPCLK1Freq();
000016  f7fffffe          BL       CLK_GetPCLK1Freq
                  |L12.26|
00001a  4681              MOV      r9,r0
00001c  b3ad              CBZ      r5,|L12.138|
;;;498        }
;;;499    
;;;500        if(u32baudrate != 0ul)
;;;501        {
;;;502            u32Div = u32PCLKFreq / u32baudrate;
00001e  fbb9f0f5          UDIV     r0,r9,r5
;;;503            u32Tmp = (u32PCLKFreq / u32Div) - u32baudrate;
;;;504            u32Tmp2 = u32baudrate - (u32PCLKFreq / (u32Div+1ul));
000022  1c43              ADDS     r3,r0,#1
000024  fbb9f1f0          UDIV     r1,r9,r0              ;503
000028  fbb9f2f3          UDIV     r2,r9,r3
00002c  1b49              SUBS     r1,r1,r5              ;503
00002e  1aaa              SUBS     r2,r5,r2
;;;505    
;;;506            if(u32Tmp >= u32Tmp2) u32Div = u32Div + 1ul;
000030  4291              CMP      r1,r2
000032  d300              BCC      |L12.54|
000034  1c40              ADDS     r0,r0,#1
                  |L12.54|
;;;507    
;;;508            u32Tmp = 0x400ul * 0x10ul;
000036  f44f4280          MOV      r2,#0x4000
;;;509            for(u32PDSCnt = 1ul; u32PDSCnt <= 0x04ul; u32PDSCnt++)
00003a  2301              MOVS     r3,#1
                  |L12.60|
;;;510            {
;;;511                if(u32Div <= (u32Tmp * u32PDSCnt)) break;
00003c  fb02f103          MUL      r1,r2,r3
000040  4281              CMP      r1,r0
000042  d203              BCS      |L12.76|
000044  1c5b              ADDS     r3,r3,#1
000046  2b04              CMP      r3,#4                 ;509
000048  d9f8              BLS      |L12.60|
00004a  e001              B        |L12.80|
                  |L12.76|
;;;512            }
;;;513    
;;;514            if(u32PDSCnt > 0x4ul) u32PDSCnt = 0x4ul;
00004c  2b04              CMP      r3,#4
00004e  d900              BLS      |L12.82|
                  |L12.80|
000050  2304              MOVS     r3,#4
                  |L12.82|
;;;515    
;;;516            u32Div = u32Div / u32PDSCnt;
000052  fbb0f6f3          UDIV     r6,r0,r3
;;;517    
;;;518            /* Find best solution */
;;;519            u32Min = (uint32_t) - 1;
;;;520            u32MinDSCnt = 0ul;
000056  f04f0800          MOV      r8,#0
00005a  f04f37ff          MOV      r7,#0xffffffff        ;519
;;;521            u32MinClkDiv = 0ul;
00005e  46c4              MOV      r12,r8
;;;522    
;;;523            for(u32DSCnt = 6ul; u32DSCnt <= 0x10ul; u32DSCnt++)   /* DSCNT could be 0x5~0xF */
000060  2106              MOVS     r1,#6
;;;524            {
;;;525                u32ClkDiv = u32Div / u32DSCnt;
;;;526    
;;;527                if(u32ClkDiv > 0x400ul)
000062  f44f6a80          MOV      r10,#0x400
                  |L12.102|
000066  fbb6f2f1          UDIV     r2,r6,r1              ;525
00006a  4552              CMP      r2,r10
00006c  d904              BLS      |L12.120|
;;;528                {
;;;529                    u32ClkDiv = 0x400ul;
;;;530                    u32Tmp = u32Div - (u32ClkDiv * u32DSCnt);
00006e  fb0a6511          MLS      r5,r10,r1,r6
000072  4652              MOV      r2,r10                ;529
;;;531                    u32Tmp2 = u32Tmp + 1ul;
000074  1c68              ADDS     r0,r5,#1
000076  e004              B        |L12.130|
                  |L12.120|
;;;532                }
;;;533                else
;;;534                {
;;;535                    u32Tmp = u32Div - (u32ClkDiv * u32DSCnt);
;;;536                    u32Tmp2 = ((u32ClkDiv+1ul) * u32DSCnt) - u32Div;
000078  1c50              ADDS     r0,r2,#1
00007a  fb026511          MLS      r5,r2,r1,r6           ;535
00007e  4348              MULS     r0,r1,r0
000080  1b80              SUBS     r0,r0,r6
                  |L12.130|
;;;537                }
;;;538    
;;;539                if(u32Tmp >= u32Tmp2)
000082  4285              CMP      r5,r0
000084  d302              BCC      |L12.140|
000086  1c52              ADDS     r2,r2,#1
;;;540                {
;;;541                    u32ClkDiv = u32ClkDiv + 1ul;
000088  e001              B        |L12.142|
                  |L12.138|
00008a  e017              B        |L12.188|
                  |L12.140|
;;;542                }
;;;543                else u32Tmp2 = u32Tmp;
00008c  4628              MOV      r0,r5
                  |L12.142|
;;;544    
;;;545                if(u32Tmp2 < u32Min)
00008e  42b8              CMP      r0,r7
000090  d203              BCS      |L12.154|
;;;546                {
;;;547                    u32Min = u32Tmp2;
000092  0007              MOVS     r7,r0
;;;548                    u32MinDSCnt = u32DSCnt;
000094  4688              MOV      r8,r1
;;;549                    u32MinClkDiv = u32ClkDiv;
000096  4694              MOV      r12,r2
;;;550    
;;;551                    /* Break when get good results */
;;;552                    if(u32Min == 0ul)
000098  d002              BEQ      |L12.160|
                  |L12.154|
00009a  1c49              ADDS     r1,r1,#1
00009c  2910              CMP      r1,#0x10              ;523
00009e  d9e2              BLS      |L12.102|
                  |L12.160|
;;;553                    {
;;;554                        break;
;;;555                    }
;;;556                }
;;;557            }
;;;558    
;;;559            /* Set USCI_UART baud rate */
;;;560            uuart->BRGEN = ((u32MinClkDiv-1ul) << UUART_BRGEN_CLKDIV_Pos) |
0000a0  481c              LDR      r0,|L12.276|
0000a2  eb002188          ADD      r1,r0,r8,LSL #10
0000a6  f1ac0001          SUB      r0,r12,#1
0000aa  ea414000          ORR      r0,r1,r0,LSL #16
0000ae  f06f01ff          MVN      r1,#0xff
0000b2  eb012103          ADD      r1,r1,r3,LSL #8
0000b6  4308              ORRS     r0,r0,r1
0000b8  60a0              STR      r0,[r4,#8]
0000ba  e00d              B        |L12.216|
                  |L12.188|
;;;561                           ((u32MinDSCnt-1ul) << UUART_BRGEN_DSCNT_Pos) |
;;;562                           ((u32PDSCnt-1ul) << UUART_BRGEN_PDSCNT_Pos);
;;;563        }
;;;564        else
;;;565        {
;;;566            u32PDSCnt = ((uuart->BRGEN & UUART_BRGEN_PDSCNT_Msk) >> UUART_BRGEN_PDSCNT_Pos) + 1ul;
0000bc  68a0              LDR      r0,[r4,#8]
0000be  f3c02301          UBFX     r3,r0,#8,#2
;;;567            u32MinDSCnt = ((uuart->BRGEN & UUART_BRGEN_DSCNT_Msk) >> UUART_BRGEN_DSCNT_Pos) + 1ul;
0000c2  68a0              LDR      r0,[r4,#8]
0000c4  f3c02884          UBFX     r8,r0,#10,#5
;;;568            u32MinClkDiv = ((uuart->BRGEN & UUART_BRGEN_CLKDIV_Msk) >> UUART_BRGEN_CLKDIV_Pos) + 1ul;
0000c8  68a0              LDR      r0,[r4,#8]
0000ca  1c5b              ADDS     r3,r3,#1
0000cc  f3c04c09          UBFX     r12,r0,#16,#10
0000d0  f1080801          ADD      r8,r8,#1
0000d4  f10c0c01          ADD      r12,r12,#1
                  |L12.216|
;;;569        }
;;;570    
;;;571        /* Set USCI_UART line configuration */
;;;572        uuart->LINECTL = (uuart->LINECTL & ~UUART_LINECTL_DWIDTH_Msk) | u32data_width;
0000d8  6ae0              LDR      r0,[r4,#0x2c]
0000da  f4206070          BIC      r0,r0,#0xf00
0000de  ea40000b          ORR      r0,r0,r11
0000e2  62e0              STR      r0,[r4,#0x2c]
;;;573        uuart->PROTCTL = (uuart->PROTCTL & ~(UUART_PROTCTL_STICKEN_Msk | UUART_PROTCTL_EVENPARITY_Msk |
0000e4  6de0              LDR      r0,[r4,#0x5c]
0000e6  490c              LDR      r1,|L12.280|
0000e8  4008              ANDS     r0,r0,r1
0000ea  9903              LDR      r1,[sp,#0xc]
0000ec  4308              ORRS     r0,r0,r1
0000ee  65e0              STR      r0,[r4,#0x5c]
;;;574                                             UUART_PROTCTL_PARITYEN_Msk)) | u32parity;
;;;575        uuart->PROTCTL = (uuart->PROTCTL & ~UUART_PROTCTL_STOPB_Msk ) | u32stop_bits;
0000f0  6de0              LDR      r0,[r4,#0x5c]
0000f2  990e              LDR      r1,[sp,#0x38]
0000f4  f0200001          BIC      r0,r0,#1
0000f8  4308              ORRS     r0,r0,r1
0000fa  65e0              STR      r0,[r4,#0x5c]
;;;576    
;;;577        return (u32PCLKFreq/u32PDSCnt/u32MinDSCnt/u32MinClkDiv);
0000fc  fbb9f0f3          UDIV     r0,r9,r3
000100  fbb0f0f8          UDIV     r0,r0,r8
000104  fbb0f0fc          UDIV     r0,r0,r12
;;;578    }
000108  b004              ADD      sp,sp,#0x10
00010a  e8bd9ff0          POP      {r4-r12,pc}
;;;579    
                          ENDP

00010e  0000              DCW      0x0000
                  |L12.272|
                          DCD      0x400d0000
                  |L12.276|
                          DCD      0xfffffc00
                  |L12.280|
                          DCD      0xfbfffff9

                          AREA ||i.UUART_Write||, CODE, READONLY, ALIGN=1

                  UUART_Write PROC
;;;591     */
;;;592    uint32_t UUART_Write(UUART_T* uuart, uint8_t pu8TxBuf[], uint32_t u32WriteBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;593    {
000002  4604              MOV      r4,r0
;;;594        uint32_t  u32Count, u32delayno;
;;;595    
;;;596        for(u32Count = 0ul; u32Count != u32WriteBytes; u32Count++)
000004  2000              MOVS     r0,#0
;;;597        {
;;;598            u32delayno = 0ul;
;;;599            while((uuart->BUFSTS & UUART_BUFSTS_TXEMPTY_Msk) == 0ul)   /* Wait Tx empty */
;;;600            {
;;;601                u32delayno++;
;;;602                if(u32delayno >= 0x40000000ul)
000006  f04f4580          MOV      r5,#0x40000000
00000a  e00c              B        |L13.38|
                  |L13.12|
00000c  2300              MOVS     r3,#0                 ;598
00000e  e002              B        |L13.22|
                  |L13.16|
000010  1c5b              ADDS     r3,r3,#1              ;599
000012  42ab              CMP      r3,r5
000014  d209              BCS      |L13.42|
                  |L13.22|
000016  6be6              LDR      r6,[r4,#0x3c]         ;599
000018  05f6              LSLS     r6,r6,#23             ;599
00001a  d5f9              BPL      |L13.16|
;;;603                {
;;;604                    break;
;;;605                }
;;;606            }
;;;607    
;;;608            if(u32delayno >= 0x40000000ul)
00001c  42ab              CMP      r3,r5
00001e  d204              BCS      |L13.42|
;;;609            {
;;;610                break;
;;;611            }
;;;612    
;;;613            uuart->TXDAT = (uint8_t)pu8TxBuf[u32Count];    /* Send USCI_UART Data to buffer */
000020  5c0b              LDRB     r3,[r1,r0]
000022  6323              STR      r3,[r4,#0x30]
000024  1c40              ADDS     r0,r0,#1
                  |L13.38|
000026  4290              CMP      r0,r2                 ;596
000028  d1f0              BNE      |L13.12|
                  |L13.42|
;;;614        }
;;;615    
;;;616        return u32Count;
;;;617    
;;;618    }
00002a  bd70              POP      {r4-r6,pc}
;;;619    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\usci_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_usci_uart_c_2f0f282b____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___11_usci_uart_c_2f0f282b____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_usci_uart_c_2f0f282b____REVSH|
#line 402
|__asm___11_usci_uart_c_2f0f282b____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___11_usci_uart_c_2f0f282b____RRX|
#line 587
|__asm___11_usci_uart_c_2f0f282b____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
